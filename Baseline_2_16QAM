% Uncoded MIMO BER | i.i.d. Rayleigh | 16-QAM | MMSE via Conjugate-Gradient
% Compare Nt=Nr in {16, 64, 128, 256, 512, 1024} on ONE figure
clear; clc; rng(2025);

%% ==== Global settings ====
sizes   = [16 64 128 256 512 1024];   % Nt = Nr
EsN0dB  = -8:4:12;                     % SNR grid (per-stream Es/N0)
frames  = 20;                          % frames per SNR (light for 1024)
Sps     = 10;                         % symbols per stream per frame (light)
M       = 16; k = log2(M);            % 16-QAM

% Conjugate-Gradient (MMSE) parameters
maxIt   = 20;                         % CG iterations
tol     = 1e-3;                       % CG tolerance

verbose = true;                       % print progress

%% ==== Storage ====
BER = zeros(numel(sizes), numel(EsN0dB));

%% ==== Main loops ====
for si = 1:numel(sizes)
    Nt = sizes(si); Nr = sizes(si);
    if verbose, fprintf('\n=== Array Nt=Nr=%d ===\n', Nt); end

    for ei = 1:numel(EsN0dB)
        EsN0   = 10^(EsN0dB(ei)/10);
        sigma2 = 1/EsN0;

        bit_err = 0; bit_all = 0;

        for fr = 1:frames
            % ---- Tx bits -> ints -> Gray QAM ----
            bits = randi([0 1], Sps*k, Nt, 'uint8');
            ints = bits2ints(bits, k);
            x    = qam_mod_gray(ints, M);

            % ---- i.i.d. Rayleigh channel ----
            H = (randn(Nr,Nt)+1i*randn(Nr,Nt))/sqrt(2);

            % ---- Rx ----
            n = sqrt(sigma2/2)*(randn(Sps,Nr)+1i*randn(Sps,Nr));
            y = x*(H.') + n;

            % ---- MMSE equalization via CG ----
            Hh = H';
            Ah = @(v,lam) Hh*(H*v) + lam*v;

            for t = 1:Sps
                b = Hh * (y(t,:).');
                xhat_t = cg_solve(@(v)Ah(v,sigma2), b, tol, maxIt);

                % Hard decision
                rx_int   = qam_demod_gray(xhat_t.', M);
                rx_bits  = ints2bits(rx_int, k);
                tx_bits  = bits((t-1)*k+(1:k), :);

                bit_err = bit_err + sum( reshape(rx_bits,[],1) ~= reshape(tx_bits,[],1) );
                bit_all = bit_all + numel(tx_bits);
            end
        end

        BER(si, ei) = bit_err / bit_all;
        if verbose
            fprintf('Nt=Nr=%4d | SNR=%+3d dB | BER=%.3e\n', Nt, EsN0dB(ei), BER(si,ei));
        end
    end
end

%% ==== Plot ====
figure; hold on; grid on;
cc = lines(numel(sizes));
for si = 1:numel(sizes)
    semilogy(EsN0dB, BER(si,:), '-o', 'LineWidth', 1.6, 'Color', cc(si,:));
end
xlabel('Es/N0 per stream (dB)'); ylabel('BER');
lg = arrayfun(@(N) sprintf('Nt=Nr=%d', N), sizes, 'UniformOutput', false);
legend(lg{:}, 'Location', 'southwest');
title(sprintf('Uncoded MIMO | 16-QAM | i.i.d. Rayleigh | MMSE (CG: it=%d, tol=%g)', maxIt, tol));
ylim([1e-5 1]); xlim([min(EsN0dB) max(EsN0dB)]);

%% ===== Helper functions =====
function x = cg_solve(Afun, b, tol, maxit)
    x = zeros(size(b)); r = b - Afun(x); p = r; rs = real(r'*r);
    for k=1:maxit
        Ap = Afun(p); alpha = rs / real(p'*Ap);
        x = x + alpha*p; r = r - alpha*Ap;
        rs_new = real(r'*r);
        if rs_new < (tol^2)*rs, break; end
        p = r + (rs_new/rs)*p; rs = rs_new;
    end
end

function ints=bits2ints(bits,k)
    [L,C]=size(bits); S=L/k; bits3=reshape(uint8(bits),k,S,C);
    w=uint32(2.^(k-1:-1:0)); ints=zeros(S,C,'uint32');
    for i=1:k, slice=squeeze(bits3(i,:,:)); ints=ints+uint32(slice).*w(i); end
end

function bits=ints2bits(ints,k)
    [S,C]=size(ints); ints=uint32(ints); bits3=zeros(k,S,C,'uint8');
    for i=1:k, shift=k-i; bits3(i,:,:) = uint8(bitand(bitshift(ints,-shift),1)); end
    bits=reshape(bits3,k*S,C);
end

function x=qam_mod_gray(ints,M)
    sM=sqrt(M); p=round(log2(sM));
    q=bitand(ints,uint32(2^p-1)); i=bitshift(ints,-p);
    ig=bitxor(i,bitshift(i,-1)); qg=bitxor(q,bitshift(q,-1));
    lv=(-double(sM-1):2:double(sM-1));
    I=lv(double(ig)+1); Q=lv(double(qg)+1);
    Es=(2/3)*(M-1); x=(I+1i*Q)/sqrt(Es);
end

function ints=qam_demod_gray(x,M)
    sM=sqrt(M); p=round(log2(sM));
    lv=(-double(sM-1):2:double(sM-1));
    Es=(2/3)*(M-1); x=x*sqrt(Es);
    idxI=quant(real(x),lv); idxQ=quant(imag(x),lv);
    ig=uint32(idxI); qg=uint32(idxQ);
    i=gray2bin(ig); q=gray2bin(qg);
    ints=bitshift(i,p)+q;
end

function idx=quant(X,lv)
    step=lv(2)-lv(1); base=lv(1);
    idxf=round((X-base)/step);
    idx=uint32(min(max(idxf,0),numel(lv)-1));
end

function y=gray2bin(g)
    y=uint32(g); t=uint32(g);
    while true, t=bitshift(t,-1);
        if all(t(:)==0), break; end
        y=bitxor(y,t);
    end
end
